var URL = require('url-extra'),
  arff = require('node-arff'),
  _ = require('underscore'),
  cheerio = require('cheerio'),
  path = require('path'),
  util = require('util'),
  exec = require('child_process').exec,

  Crawler = require('./Crawler'),
  Class = require('./Class');

var Classifier = module.exports = Class.extend({

  pages: [],

  options: {
    politeness: 10,
    maxpages: 50,
    quiet: false, // whether to run in quiet mode
    arffFile: "pages.arff", // filename of generated arff file
    modelFile: "pages.model" // filename of model generated by weka
  },

  /**
   *
   * @param options
   */
  init: function (options) {
    _.bindAll(this);
    _.extend(this.options, options);
    this.crawler = new Crawler(this.options);
  },

  /**
   * Classify all pages under path as "Mobile", all other as "Not Mobile"
   * @param seedURL
   */
  classifyMobile: function (seedURL) {

    this.seedURL = URL.parse(seedURL);

    this.Log('classifying pages under %s as mobile', this.seedURL.format());

    this.crawler.on('start:worker', this.beforeCrawl);
    this.crawler.on('receive:page', this.receivePage);
    this.crawler.on('end', this.afterCrawl);

    this.crawler.crawl(this.seedURL);
  },

  /**
   *
   * @param worker
   */
  beforeCrawl: function (worker) {
    // limit fetching to pages under mobile for now
    worker.pageList.filter = function (page) {
      return page.url.inPathOf(this.seedURL);
    }.bind(this);
  },

  /**
   *
   * @param page
   * @param worker
   */
  receivePage: function (page, worker) {

    var max = this.options.maxpages;
    var mobile = page.url.inPathOf(this.seedURL);

    var data = {
      corpus: page.getCorpus(),
      classification: mobile ? "Mobile" : "Not Mobile"
    };

    this.Log('%s : %s', page, data.classification);

    this.pages.push(data);
    // when we've received 50% of mobile pages, change filter to use non-mobile
    if (this.pages.length == Math.floor(max / 2)) {
      worker.pageList.filter = function (page) {
        return !page.url.inPathOf(this.seedURL);
      }.bind(this);
    }
  },

  /**
   *
   */
  afterCrawl: function () {
    if (this.pages.length == 0) {
      this.Log('No pages crawled. Stopping.');
      return;
    }

    var filePath = path.join(process.cwd(), this.options.arffFile);

    var attributes = {
      corpus: arff.STRING,
      classification: arff.NOMINAL("Mobile", "Not Mobile")
    };

    arff.save(filePath, attributes, this.pages, function () {
      this.Log('saved model: %s', filePath);
      //     this.trainModel(filePath, path.join(process.cwd(), this.options.modelFile));

    }.bind(this));
  },


  /**
   * Train a model from pages.arff
   */
  trainModel: function (infile, outfile) {
    var classifier = 'weka.classifiers.bayes.NaiveBayes';

    var command = util.format('java %s -t %s -d %s', classifier, infile, outfile);

    // filter
    this.filterModel(infile, function (error) {

      if (error !== null) {
        this.Log('Error filtering arff file: ' + error);
      }

      // then train the model
      exec(command, function (error) {
        if (error !== null) {
          this.Log('Error filtering arff file: ' + error);
        }

      }.bind(this));
    }.bind(this));

  },

  /**
   *
   * @param callback
   */
  filterModel: function (callback) {
    var filter = 'weka.filters.unsupervised.attribute.StringToWordVector -W 500 -R first-last';
    var tokenizer = 'weka.core.tokenizers.NGramTokenizer -min 1 -max 3';

    var infile = this.options.arffFile;
    var outfile = 'filtered-' + infile;
    var command = util.format('java %s -tokenizer "%s" -i orig.arff -o out.arff', filter, tokenizer, infile, outfile);

    exec(filtering, callback);
  },

  /**
   * @constructor
   */
  Log: function () {
    if (this.options.quiet) {
      return;
    }
    arguments[0] = 'classifier: ' + arguments[0];
    console.log.apply(console, arguments);
  }
});
